%{
    #include <iostream>
    #include <string>
    #include <stdio.h>
    #include <math.h>
    using namespace std;
    int yylex();
    int yyerror(const char* p) { cerr << "Error!" << endl; return 0;};
%}

/* declare tokens */
%union {
    int val;
    char sym;
    char* str;
    bool b;
}
%token NUM
%token BOOL
%token OPP
%token CLP
%token OPB
%token CLB
%token OPSB
%token CLSB
%token CMA
%token ENDSEC
%token ADD
%token SUB
%token MUL
%token DIV
%token ASG
%token EXP
%token COL
%token GT
%token LT
%token NE
%token EQ
%token GTE
%token LTE
%token UPDATE_TK
%token SETUP_TK
%token LET
%token IF
%token THEN
%token ELSE
%token ENDIF
%token KEYBD
%token ID
%token STR
%token EOS

%type<val> NUM
%type<b> BOOL
%type<str> STR
%%


setup: start_setup setup_block end_setup
start_setup: OPSB SETUP_TK CLSB 
setup_block: setup_stmt setup_block | setup_stmt
end_setup: OPSB ENDSEC SETUP_TK CLSB

setup_stmt: bgchange {printf("bgchange\n");}
            | paramchange {printf("paramchange\n");}
            | keybindchange {printf("keybindchange\n");}

bgchange: identifier ASG identifier EOS {printf("bgchange"); }
paramchange: LET identifier ASG expr EOS | identifier ASG expr EOS {printf("paramchange"); }
keybindchange: KEYBD STR STR EOS {printf("Keybind change");}
 
expr: 
    NUM
/* |   expr ADD expr { $$ = $1 + $3; }
|   expr SUB expr { $$ = $1 - $3; }
|   expr MUL expr { $$ = $1 * $3; }
|   expr DIV expr { $$ = $1 / $3; }
|   expr EXP expr { $$ = pow($1, $3); }
|   OPP expr CLP { $$ = $2; } */
/* 
definition: LET identifier ASG OPSB array CLSB EOS
            | LET identifier ASG identifierexpression EOS
identifierexpression: identifier EOS//i am not doing tetronimo arithmetic
array: NUM CMA NUM CMA NUM CMA NUM CMA NUM CMA NUM CMA NUM CMA NUM CMA NUM */
identifier: STR
%%

int main()
{
    yyparse();
    return 0;
}

/* calclist: 
|   line calclist

line:
    expr EOL { printf("= %d\n", $1); }
|   EOL;

expr:
    NUMBER
|   expr LOGI_LSHIFT expr { $$ = $1 << $3; }
|   expr LOGI_RSHIFT expr { $$ = (unsigned int)$1 >> $3; }
|   expr ARIT_LSHIFT expr { $$ = $1 << $3; }
|   expr ARIT_RSHIFT expr { $$ = $1 >> $3; }
|   expr ADD expr { $$ = $1 + $3; }
|   expr SUB expr { $$ = $1 - $3; }
|   expr MUL expr { $$ = $1 * $3; }
|   expr DIV expr { $$ = $1 / $3; }
|   SUB expr %prec UMINUS { $$ = - $2; }
|   expr POWER expr { $$ = pow($1, $3); }
|   OPAREN expr CPAREN { $$ = $2; } */

