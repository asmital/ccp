%{
    #include <iostream>
    #include <string>
    #include <stdio.h>
    #include <math.h>
    #include "game.cpp"
    #include <vector>
    #include <map>
    using namespace std;
    int pwr(int a, int b);
    int yylex();
    int yyerror(const char* p) { cerr << "Error!" << p << endl; return 0;};
    extern char yytext[];
    vector<vector<int>> blocks;
	map<string, double> generic_rules;
%}

/* %define api.value.type { std::string } */

%code requires {
    #include <string.h>
}

/* declare tokens */
%union {
    int val;
    char sym;
    char* id;
    char* str;
};
%token<val> NUM
%token<val> BOOL
%token OPP CLP
%token OPB CLB
%token OPSB CLSB
%token CMA
%token ENDSEC
%token ADD SUB
%token MUL DIV
%token ASG
%token EXP
%token COL
%token GT LT
%token NE EQ
%token GTE LTE
%token UPDATE_TK SETUP_TK
%token LET
%token IF
%token THEN
%token ELSE
%token ENDIF
%token<str> KEYBD
%token ID
%token SSTR
%token EOS

%type<str> identifier
%type<val> stored_identifier
%type<str> sstring
%type<val> expr
%type<val> factor
%type<val> term
%type<val> subterm
%type<val> uterm

%%


setup: start_setup setup_block end_setup
start_setup: OPSB SETUP_TK CLSB 
setup_block: setup_stmt setup_block | setup_stmt
end_setup: OPSB ENDSEC SETUP_TK CLSB

setup_stmt: bgchange | keybindrule | genericrule | blockrule | arrayrule

bgchange: identifier ASG sstring EOS { cout << "bgchange " << $1 << " " << $3 << endl; }

keybindrule: KEYBD identifier identifier EOS {cout<< "keybind " << $2<< " " << $3 <<endl; }

genericrule: identifier ASG expr EOS
{ 
    cout <<"genericrule " << $1 << " " << $3 << endl; 
    generic_rules.insert(pair<string, double>($1, $3));
}

blockrule: LET identifier ASG expr EOS { cout << "blockrule " << $2 << " " << $4 << endl; }

arrayrule: LET identifier ASG OPSB array CLSB EOS{ cout <<"arrayrule " << $2 << " " << endl; }

array: NUM CMA NUM CMA NUM CMA NUM CMA NUM CMA NUM CMA NUM CMA NUM CMA NUM { cout << "array " << $1<< " " << $3<< " " << $5<< " " << $7<< " " <<endl;}


identifier:
    ID { $$ = strdup(yylval.id); }
sstring:
    SSTR { $$ = strdup(yylval.str); }

    
/* component may have ADD/SUB operators among factors */
expr: 
  factor
| expr ADD factor {$$ = $1 + $3;}
| expr SUB factor {$$ = $1 - $3;}
| BOOL
;
 
/* factor may have MUL/DIV operators among terms */
factor: term
| factor MUL term {$$ = $1 * $3;}
| factor DIV term {if($3) $$ = $1 / $3; else yyerror("Division by zero\n");}
;
 
/* term comprises of subterms which may have power operator */
term: subterm
| term EXP subterm {$$ = pwr($1, $3);}
;
 
/* this rule supports unary plus/minus (Associativity RIGHT-TO-LEFT) */
subterm: uterm
| SUB uterm {$$ = -$2;}
| ADD uterm {$$ = $2;}
;

/* this rule supports brackets in the grammar */
uterm: NUM
| stored_identifier
| OPP expr CLP {$$ = $2;}
;

stored_identifier: 
    ID { 
        string label = strdup(yyval.str); 
        auto it = generic_rules.find(label);  
        if (it == generic_rules.end())
        {
            cout << "Variable " << label << " unassigned" << endl;
            yyerror("Variable unassigned");
        }
        $$ = it->second;
    }





%%
/* pow in cmath works with doubles. i needed integers */
int pwr(int a, int b)
{
    if(b < 0) return 0;
    int res = 1;
    for(int i = 0; i < b; i++)
        res *= a;
    return res;
}
 

int main()
{
    /* #ifdef YYDEBUG
        yydebug = 1;
    #else 
    #endif
    */
    yyparse();
    /* gameloop(); */
    for (const auto &[k, v] : generic_rules)
        std::cout << "m[" << k << "] = (" << v << ") " << std::endl; 
    return 0;
}

